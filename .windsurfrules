You are an expert in Python, FastAPI, scalable API development, TypeScript, React, Tailwind, and Shadcn UI.

Key Principles
Write concise, technical responses with accurate examples in both Python and TypeScript.
Use functional and declarative programming patterns; avoid classes unless absolutely necessary.
Prefer iteration and modularization over code duplication.
Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission, isLoading, hasError).
Follow proper naming conventions:
For Python: use lowercase with underscores (e.g., routers/user_routes.py).
For TypeScript: use lowercase with dashes for directories (e.g., components/auth-wizard).
Pydantic Best Practices
Use ConfigDict for Configuration: Define model configurations using ConfigDict to manage settings like arbitrary_types_allowed.
Field Validation: Utilize @field_validator decorators for field validation. Ensure that all fields have appropriate validation logic.
Type Annotations: Always use type annotations for fields to enhance clarity and enable type checking.
Model Inheritance: Use inheritance to create base models for shared fields and validation logic, promoting code reuse.
Avoid Mutable Default Arguments: Use default_factory for mutable types (like lists or dictionaries) to avoid unexpected behavior.
Utilize Pydantic V2 Features: Take advantage of new features in Pydantic V2, such as @computed_field for derived properties and improved serialization methods.
Consistent Naming Conventions: Follow consistent naming conventions for fields, using lowercase with underscores.
Error Handling: Implement custom error handling in your models to provide clear and descriptive error messages for validation failures.
Documentation: Document your models and fields using the description parameter in Field() to improve code maintainability and usability.
Testing: Write unit tests for your models to ensure that validation logic works as expected.
Project Structure
Frontend:
Language: TypeScript
Framework: React
UI Library: Tailwind CSS, Shadcn UI
Build Tool: Vite
Directory Structure:
frontend/src/: Main source code
frontend/src/index.html: Main HTML file
Configuration Files:
vite.config.ts
tsconfig.json
tailwind.config.js
postcss.config.js
Docker Files:
Dockerfile
Dockerfile.dev
Backend:
Language: Python
Framework: FastAPI
Database: PostgreSQL
Directory Structure:
backend/src/: Main source code
backend/tests/: Tests
document-processor/: Document processing utilities
Environment Configuration:
.env / .env.example: Environment variables
Database Configuration:
alembic.ini
ddialog.db: SQLite database for local development
Docker Files:
Dockerfile
Dockerfile.dev
Code Style and Structure
Backend (Python/FastAPI):

Use def for pure functions and async def for asynchronous operations.
Type Hints: Use Python type hints for all function signatures. Prefer Pydantic 2.0 models for input validation.
File Structure: Follow clear separation with directories for routes, utilities, static content, and models/schemas.
RORO Pattern: Use the "Receive an Object, Return an Object" pattern.
Error Handling:
Handle errors at the beginning of functions with early returns.
Use guard clauses and avoid deeply nested if statements.
Implement proper logging and custom error types.
Frontend (TypeScript/React):

TypeScript Usage: Use TypeScript for all code. Prefer interfaces over types. Avoid enums; use maps instead.
Functional Components: Write all components as functional components with proper TypeScript interfaces.
UI and Styling: Implement responsive design using Tailwind CSS with Shadcn UI, adopting a mobile-first approach.
Performance:
Minimize use client, useEffect, and setState hooks. Favor server-side rendering where possible.
Wrap client components in Suspense with fallback for improved performance.
Performance Optimization
Backend:

Asynchronous Operations: Minimize blocking I/O operations using async functions.
Caching: Implement caching strategies for frequently accessed data using Redis or in-memory stores.
Lazy Loading: Use lazy loading techniques for large datasets and API responses.
Frontend:

React Components: Favor server-side rendering and avoid heavy client-side rendering where possible.
Dynamic Loading: Implement dynamic loading for non-critical components and optimize image loading using WebP format with lazy loading.
Project Conventions
Backend:

Follow RESTful API design principles.
Rely on FastAPIâ€™s dependency injection system for managing state and shared resources.
Use SQLAlchemy 2.0 for ORM features, if applicable.
Ensure CORS is properly configured for local development.
No authentication or authorization is required for users to access the platform.
Frontend:

Optimize Web Vitals (LCP, CLS, FID).
Limit use client hooks to small, specific components for Web API access.
Use Docker for containerization and ensure easy deployment.
Testing and Deployment
Implement unit tests for both frontend and backend.
Use Docker and docker compose for orchestration in both development and production environments. Avoid using the obsolete docker-compose command.
Ensure proper input validation, sanitization, and error handling throughout the application.